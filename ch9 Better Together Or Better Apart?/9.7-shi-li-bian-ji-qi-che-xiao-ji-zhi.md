# 9.7 示例：编辑器撤销机制

在第6.2节的GUI编辑器项目中，其中一个要求是支持多级撤销/重做，不仅是对文本本身的改变，也包括对选择、插入光标和视图的改变。例如，如果用户选择了一些文本，将其删除，滚动到文件的不同位置，然后调用撤销，编辑器必须将其状态恢复到删除前的状态。这包括恢复被删除的文本，再次选择它，并使被选择的文本在窗口中可见。

一些学生项目将整个撤销机制作为文本类的一部分来实现。文本类维护了一个所有可撤销的修改的列表。每当文本被改变时，它就会自动向这个列表添加条目。对于选择、插入光标和视图的改变，用户界面代码会调用文本类中的额外方法，然后将这些改变的条目添加到撤销列表中。当用户要求撤销或重做时，用户界面代码调用文本类中的一个方法，然后处理撤销列表中的条目。对于与文本有关的条目，它更新了文本类的内部结构；对于与其他事物有关的条目，如选择，文本类回调到用户界面代码来执行撤销或重做。

这种方法导致了文本类中一系列尴尬的功能。撤销/重做的核心包括一个通用的机制，用于管理已经执行的动作列表，并在撤销和重做操作中对它们进行步进。该核心位于文本类中，同时还有特殊用途的处理程序，用于实现对特定事物的撤销和重做，如文本和选择。用于选择和光标的特殊用途的撤销处理程序与文本类中的其他东西无关；它们导致了文本类和用户界面之间的信息泄漏，以及每个模块中额外的方法来回传递撤销信息。如果将来在系统中加入一种新的可撤销实体，就需要对文本类进行修改，包括针对该实体的新方法。此外，通用的撤销核心与该类中的通用文本设施没有什么关系。&#x20;

这些问题可以通过提取撤销/重做机制的通用核心并将其放在一个单独的类中来解决。

```
public class History {
    public interface Action { 
        public void redo(); 
        public void undo(); 
    }

    History() {...}

    void addAction(Action action) {...} 
    void addFence() {...}

    void undo() {...} 
    void redo() {...}
}
```

在这种设计中，History类管理着一个实现History.Action接口的对象集合。每个History.Action描述一个单一的操作。例如文本插入或光标位置的改变，并且它提供了可以撤销或重做操作的方法。History类对存储在操作中的信息或它们如何实现其撤销和重做方法一无所知。History维护一个历史列表，描述在一个应用程序的生命周期内执行的所有操作，它提供撤销和重做方法，通过列表向前和向后走，以响应用户要求的撤销和重做，调用History.Actions中的撤销和重做方法。

History.Actions是特殊用途的对象：每个对象都能理解一种特殊的可撤销操作。特定种类的可撤销操作。它们在历史类之外实现，在理解特定种类的可撤销操作的模块中。文本类可以实现UndoableInsert和UndoableDelete对象来描述文本的插入和删除。每当它插入文本时，文本类会创建一个新的可撤销插入对象来描述插入，并调用 History.addAction 来将其添加到历史列表中。编辑器的用户界面代码可能创建UndoableSelection和UndoableCursor对象，描述对 选择和插入光标的变化。

历史类也允许动作分组，因此，例如，用户的一个撤销请求可以恢复被删除的文本，重新选择被删除的文本，以及重新定位插入光标。有许多方法来分组操作；历史类使用栅栏，这是放置在历史列表中的标记，用来分隔相关操作的组。每次调用 History.redo 都会在历史列表中向后走，撤销动作，直到到达下一个栅栏。栅栏的位置由高层代码通过调用History.addFence决定。

这种方法将撤销操作的功能分为三类，每一类都在不同的地方实现。

一个通用的机制，用于管理和分组操作以及 调用撤销/重做操作的通用机制（由 History 类实现）。

特定操作的具体细节（由各种类实现。每个类都能理解少量的动作类型）。

动作分组的策略（由高级用户界面代码实现，以提供正确的整体应用行为）。代码来提供正确的整体应用行为）。

这些类别中的每一个都可以在不了解其他类别的情况下实现。历史类不知道什么样的动作被撤销；它可以被用于各种应用。每个动作类只理解单一种类的动作，历史类和动作类都不需要知道动作分组的策略。

关键的设计决定是将撤销机制的通用部分与特殊用途的部分分开，并将通用部分放在一个单独的类中。一旦这样做了，其余的设计就自然而然地出来了。

注意：将通用代码与特殊用途代码分开的建议是指与特定机制有关的代码。例如，特殊用途的撤销代码（如撤销文本插入的代码）应该与通用撤销代码（如管理历史列表的代码）分开。然而，将一种机制的特殊用途代码与另一种机制的通用代码结合起来往往是有意义的。文本类就是一个例子：它实现了一个管理文本的通用机制，但它包括与撤销有关的特殊目的代码。撤销代码是特殊用途的，因为它只处理对文本修改的撤销操作。把这段代码与历史类中的通用撤销基础结构结合起来是没有意义的，但把它放在文本类中是有意义的，因为它与其他文本功能密切相关。&#x20;
