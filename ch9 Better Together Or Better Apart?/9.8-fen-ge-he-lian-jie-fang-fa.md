# 9.8 分割和连接方法

何时细分的问题不仅适用于类，也适用于方法：是否有的时候，将一个现有的方法分成多个小方法更好？或者，是否应该将两个较小的方法合并成一个较大的方法？长的方法往往比短的方法更难理解，所以很多人认为仅仅是长度就可以作为拆分一个方法的理由。课堂上的学生经常被赋予严格的标准，例如 "把任何超过20行的方法拆开！"

然而，长度本身很少是拆分一个方法的好理由。一般来说，开发者倾向于将方法分割得过多。拆分一个方法会引入额外的接口，从而增加了复杂性。它还分离了原始方法的各个部分，如果这些部分实际上是相关的，那么代码就更难读了。你不应该拆分一个方法，除非它使整个系统变得更简单；我将在下面讨论这种情况如何发生。

长方法并不总是坏事。例如，假设一个方法包含5个20行的代码块，按顺序执行。如果这些代码块是相对独立的，那么这个方法就可以一次阅读和理解一个代码块；将每个代码块移到一个单独的方法中并没有什么好处。如果这些块有复杂的相互作用，那么把它们放在一起就更重要了，这样读者就可以一次看到所有的代码；如果每个块都在一个单独的方法中，读者就不得不在这些分散的方法之间来回翻阅，以了解它们是如何一起工作的。包含数百行代码的方法如果有一个简单的签名，并且容易阅读就可以了。这些方法很有深度（功能很多，界面简单），这很好。

![图9.3：一个方法（a）可以通过提取一个子任务（b）或将其功能分成两个独立的方法（c）来进行拆分。如果一个方法产生了浅层的方法，就不应该被拆分，如（d）。](<../.gitbook/assets/image (1).png>)

在设计方法时，最重要的目标是提供干净和简单的抽象。每个方法都应该做一件事，而且要做得完整。方法应该有一个干净简单的接口，这样用户就不需要在脑子里有很多信息就能正确使用它。该方法应该是深入的：它的接口应该比它的实现简单得多。如果一个方法具备所有这些特性，那么它是否冗长可能并不重要。

只有当拆分一个方法的结果是更干净的抽象时，它才有意义。有两种方法可以做到这一点，如图9.3所示。最好的方法是将一个子任务分解成一个单独的方法，如图9.3（b）所示。细分的结果是一个包含子任务的子方法和一个包含原方法剩余部分的父方法；父方法调用子方法。新的父方法的接口与原方法相同。如果有一个子任务可以与原方法的其余部分干净地分开，这种形式的细分是有意义的，这意味着（a）阅读子方法的人不需要知道关于父方法的任何事情，（b）阅读父方法的人不需要理解子方法的实现。通常情况下，这意味着子方法是相对通用的：可以想象它可以被除父方法之外的其他方法所使用。如果你做了这种形式的拆分，然后发现自己在父方法和子方法之间来回翻转，以了解它们是如何一起工作的，这就是一个红旗（"连在一起的方法"），表明这种拆分可能是一个坏主意。

分割一个方法的第二种方式是将其分割成两个独立的方法，每个方法对原始方法的调用者都是可见的，如图9.3（c）。如果原来的方法有一个过于复杂的接口，因为它试图做多个没有密切联系的事情，那么这种做法是有意义的。如果是这种情况，也许可以将该方法的功能分成两个或更多的小方法，每个方法只具有原方法的一部分功能。如果你做了这样的分割，那么所产生的每个方法的接口应该比原始方法的接口更简单。理想情况下，大多数调用者应该只需要调用这两个新方法中的一个；如果调用者必须同时调用这两个新方法，那么就会增加复杂性，这使得拆分不可能是一个好主意。新的方法将在它们所做的事情上更加集中。如果新的方法比原来的方法更具有通用性（也就是说，你可以想象在其他情况下分别使用它们），这是个好现象。

图9.3(c)所示形式的拆分并不常见，因为它们会导致调用者不得不处理多个方法而不是一个。当你以这种方式拆分时，你有可能会出现图9.3(d)中那样的几个浅层方法。如果调用者不得不调用每个独立的方法，在它们之间来回传递状态，那么拆分就不是一个好主意。如果你正在考虑像图9.3(c)中那样的拆分，你应该根据它是否能简化调用者的事情来判断。

在有些情况下，系统也可以通过将方法连接在一起而变得更简单。例如，连接方法可能会用一个更深的方法取代两个浅层的方法；可能会消除代码的重复；可能会消除原始方法之间的依赖关系，或者中间数据结构；可能会产生更好的封装，从而使以前存在于多个地方的知识现在被隔离在一个地方；或者可能会产生更简单的接口，正如第9.2节中所讨论的。&#x20;

{% hint style="danger" %}
#### 危险信号：连体方法

应该可以独立地理解每个方法。如果你不能理解一个方法的实现而不去理解另一个方法的实现，这就是一个红旗。这个红旗也可以在其他情况下出现：如果两段代码在物理上是分开的，但每段代码只能通过看另一段来理解，这就是一个红旗。
{% endhint %}

