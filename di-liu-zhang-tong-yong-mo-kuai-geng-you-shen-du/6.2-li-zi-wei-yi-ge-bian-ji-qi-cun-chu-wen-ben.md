# 6.2 例子：为一个编辑器存储文本

让我们考虑一个软件设计课上的例子，学生被要求建立简单的GUI文本编辑器。这些编辑器必须显示一个文件，并允许用户指点、点击和输入来编辑该文件。编辑器必须支持同一文件在不同窗口中的多个同步视图；它们还必须支持对文件的多级撤销和重做。

每个学生项目都包括一个管理文件底层文本的类。文本类通常提供将文件加载到内存中的方法，读取和修改文件的文本，并将修改后的文本写回文件。

许多学生团队为文本类实现了特殊用途的API。他们知道该类将用于一个交互式编辑器，所以他们考虑了编辑器必须提供的功能，并根据这些特定的功能定制了文本类的API。例如，如果编辑器的用户输入了退格键，编辑器就会删除光标左边的字符；如果用户输入了删除键，编辑器就会删除光标右边的字符。了解到这一点，一些团队在文本类中创建了一个方法来支持这些具体的功能：

```
void backspace(Cursor cursor); 
void delete(Cursor cursor);
```

这些方法中的每一个都将光标位置作为其参数；一个特殊的类型Cursor代表这个位置。编辑器还必须支持一个可以复制或删除的选择。学生们通过定义一个选择类并在删除时将该类的对象传递给文本类来处理这个问题。

```
void deleteSelection(Selection selection);
```

学生们可能认为，如果文本类的方法与用户可见的功能相对应，那么实现用户界面会更容易。但实际上，这种专业化的做法对用户界面的代码没有什么好处，而且对从事用户界面或文本类工作的开发人员造成了很高的认知负担。文本类最终有大量的浅层方法，每一个都只适合于一个用户界面操作。许多方法，如删除，只在一个地方被调用。结果是，从事用户界面工作的开发人员不得不了解大量的文本类方法。

这种方法在用户界面和文本类之间造成了信息泄露。与用户界面相关的抽象，如选择或退格键，都反映在文本类中；这增加了从事文本类的开发者的认知负担。每一个新的用户界面操作都需要在文本类中定义一个新的方法，所以一个从事用户界面工作的开发者很可能最终也会在文本类中工作。类设计的目标之一是允许每个类独立开发，但专门的方法将用户界面和文本类绑在一起。
