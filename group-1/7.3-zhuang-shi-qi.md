# 7.3 装饰器

装饰器设计模式（也被称为 "包装器"）是一种鼓励API跨层重复的模式。装饰器对象采用一个现有的对象并扩展其功能；它提供与底层对象相似或相同的API，其方法调用底层对象的方法。在第四章的Java I/O例子中，BufferedInputStream类是一个装饰器：给定一个InputStream对象，它提供相同的API，但引入了缓冲功能。例如，当它的读取方法被调用来读取一个字符时，它在底层InputStream上调用读取来读取一个更大的块，并保存额外的字符以满足未来的读取调用。另一个例子发生在窗口系统中：一个Window类实现了一个简单的不可滚动的窗口形式，而一个ScrollableWindow类通过添加水平和垂直滚动条装饰了Window类。

装饰器的动机是将一个类的特殊用途的扩展与一个更通用的核心分开。然而，装饰器类往往是浅层的：它们为少量的新功能引入大量的模板。装饰者类通常包含许多直通方法。很容易过度使用装饰器模式，为每个小的新功能创建一个新的类。这就导致了浅层类的爆炸，例如Java I/O的例子。

在创建装饰器类之前，请考虑如下的替代方案。

你能不能把新的功能直接添加到底层类中，而不是创建一个装饰类？而不是创建一个装饰器类？如果新的功能是 相对来说是通用的，或者它与底层类有逻辑上的联系。或者如果底层类的大多数用途也将使用新的功能。

例如，几乎所有创建Java InputStream的人也会 创建一个 BufferedInputStream，而缓冲是 I/O 的一个自然部分，所以 这些类应该被结合起来。

如果新的功能是专门针对某个特定的用例的，那么将它与 是否有必要将其与用例合并，而不是创建一个单独的 类？

你能否将新功能与现有的装饰器合并，而不是创建一个新的装饰器？而不是创建一个新的装饰器？这将导致一个更深的 装饰器类，而不是多个浅层的装饰器。

最后，问问自己，新的功能是否真的需要包裹现有的功能：你能不能把它实现为一个独立的类，独立于基类？在窗口化的例子中，滚动条可能可以从主窗口中单独实现，而不需要包裹其所有的现有功能。

有时装饰器是有意义的，但通常有一个更好的选择。
